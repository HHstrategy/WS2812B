# WS2812B实现

## 一、硬件概述

### WS2812B概述

#### WS281x 系列

​		WS2812B 系列中的“智能控制 LED 光源”是令人惊叹的设备（如 WS2812 和 WS2811）。特别是，它们是智能控制LED光源，带有控制电路和RGB驱动电路，两者都集成在单个5050组件封装中，它们包括内部智能数字端口数据锁存器以及信号整形和放大电路。

​		还配备了精密内部振荡器和可编程恒流驱动器，有效地确保每个像素输出的光量（每种颜色）与编程的光量一致。数据传输协议使用单线NZR通信模式。复位后器件上电后，DIN端口从微控制器接收数据。



#### WS281x 特性

​	反向电源连接保护，不损坏IC

​	只需三根线

​	所有电路和 LED 集成在单个 5050 封装中

​	内置信号整形电路，波形失真不累积

​	内置电气复位电路和断电复位电路

​	三原色每颗LED可达到256亮度度，支持1600万色

​	单线级联端口传输信号

​	两个设备之间的距离可以超过5m，无需任何额外的组件

​	当刷新率为30Hz时，单线可连接1024个以上的LED

​	数据线以800Kbps的速度运行

​	由于集成了恒流驱动器，灯光的颜色高度一致

​	

#### 通信

WS2812B最有用和最独特的特点之一是可以用单个MCU的线路驱动多个MCU。这是因为更多的WS281x可以以级联方式连接，如下图所示

![img](https://i0.hdslb.com/bfs/article/1ad6f2ffce49908f1a09ce7ad4c99ee5b27d9178.png@560w_966h_progressive.webp)


第一个器件（图中上部）从MCU接收所有数据，但删除前24位（这些位编码其自己的RGB代码），并将其他器件转发到下一个级联连接器件



有一个更清晰的想法，请参阅此图

![img](https://i0.hdslb.com/bfs/article/eb04934f8d51bf23724c8c77ec003103a960519a.png@942w_531h_progressive.webp)


D1 是第一个设备，它接收所有数据并转发除第一个设备之外的所有数据。D2（按顺序，第二个设备）接收除第一个设备之外的所有数据，并再次转发除前两个设备之外的所有数据。等等..

这种机制可以无限期地复制，因为每个器件都执行信号整形和放大。这允许到达更远的距离，因为我们从MCU输出的信号在到达最远LED的过程中在每个WS2812B上重新生成。



通信遵循800kHz的高频NRZ协议。此外，每个位必须根据高和低时间进行编码。

![img](https://i0.hdslb.com/bfs/article/8b47dcf81f20a7c95fda79a7627f5f7a0b4deeda.png@755w_438h_progressive.webp)


从上图中，我们有 5 个不同的间隔，其中 4 个必须准确遵循：T0H、T0L、T1H、T1L。数据表上报告时序不严格（我们的裕量为 +-150ns），因此我们可以将这些间隔恢复为：

**位 0** 周期高点的 1/3，周期低点的 2/3

**位1**  2/3 周期高点，1/3 周期低点

**重置** 保持低电平至少 40 个周期（50us 是大约 40 个周期的 1.25us）

每个WS2812B需要24位数据来再现颜色。事实上，每种颜色都由 3 组 8 位组成，每组 8 位代表其 RGB 编码。此数据必须按照此顺序发送。

![img](https://i0.hdslb.com/bfs/article/5e2ca5db6f368686764fb27f2c003ed3bede5eac.png@942w_42h_progressive.webp)

#### 驱动

我们需要创建一个具有高频率NRZ编码的位流。我们如何解决这个问题？我们基本上有两种方法：

直接控制GPIO，同时考虑有关时间的约束

使用一个或多个外围设备卸载 CPU

从某些方面来说，第一个方法更简单。我们为 T0H、T0L、T1H、T1L 和三个函数硬编码了四种不同的延迟：一个用于发送位 0，一个用于发送位 1，一个用于重置，0 采用颜色并生成相应的 24 个函数序列。显然，它效率不高，并且长时间占用我们的CPU（特别是如果我们连接一长条LED）。

相反，第二种方法旨在尽可能多地卸载CPU，利用两个外围设备（在我的例子中是TIMER和DMA）以及MCU的一些RAM。如何将所有这些东西粘合在一起？

从数据表中，我们知道每个位的特征是固定周期为1.25us。此间隔对应于 800kHz 的频率。此外，仔细查看协议，我们可以注意到唯一改变的是每个时期的高部分。它类似于PWM信号。STM32 MCU上的大多数定时器都可以动态地生成不同的PWM信号。因此，在正确的时间改变定时器产生的PWM信号，可以按照WS2812B系列特定协议输出任意系列的1和0。

这还不够。如果我们只使用定时器，我们还需要 CPU 不断改变 TIMER PWM 的高间隔，因此我们仍然加载 CPU。另一个外围设备在我们的帮助下，DMA。它是一个外围设备，基本上将数据流从一个寄存器移动到另一个寄存器（或从内存的一部分移动到另一个，或这些的混合）。由于DMA还可以与请求或中断同步进行这些传输，因此我们可以使用它来更新从TIMER生成的PWM。

这里有一个问题。DMA 不是 CPU，因此它需要移动一堆已经可用（和计算）的数据。这就要求存储器的位置必须包含定时器应产生的PWM序列。所需的内存量与我们需要控制的WS281x设备量成正比。

每个 WS2812B 需要 24 个不同的 PWM 来表示颜色。此外，RESET信号必须是PWM，没有大约40个周期的高电平时间（但我肯定使用了50个）。我说的是周期数，因为DMA配置为在每个PWM信号结束时更新定时器的PWM值。

因此所需的字节数为：**50 + 24 * #WS281x**，每个PWM周期一个。

最后一步是配置（仅）一个 GPIO，以便它可以输出定时器给出的 PWM。 

作者：墓碑上的褐色蚁 https://www.bilibili.com/read/cv19918823?spm_id_from=333.999.0.0 出处：bilibili

### STM32F103C8T6

STM32F103C8T6是一款由意法半导体公司（ST）推出的基于Cortex-M3内核的32位微控制器，硬件采用LQFP48封装，属于ST公司微控制器中的STM32系列。除了被我们熟知的STM32，ST公司还有SPC5X系列、STM8系列等，具体参数如下：

|      内核      |                          Cortex-M3                           |
| :------------: | :----------------------------------------------------------: |
|     Flash      |                          64K x 8bit                          |
|      SRAM      |                          20K x 8bit                          |
|      GPIO      |    37个GPIO，分别为PA0-PA15、PB0-PB15、PC13-PC15、PD0-PD1    |
|      ADC       | 2个12bit ADC合计12路通道，外部通道：PA0到PA7+PB0到PB1，内部通道：温度传感器通道ADC_Channel_16和内部参考电压通道ADC_Channel_17 |
|     Timers     | 4个16bit定时器/计数器，分别为TIM1、TIM2、TIM3、TIM4                         TM1带死区插入，常用于产生PWM控制电机 |
|     Timers     |      2个看门狗定时器（独立看门狗IWDG、窗口看门狗WWDG）       |
|     Timers     |             1个24bit向下计数的滴答定时器systick              |
| 工作电压、温度 |                    2V~3.6V、-40°C ~ 85°C                     |
|    通信串口    |                 2*IIC，2*SPI，3*USART，1*CAN                 |
|    系统时钟    | 内部8MHz时钟HSI最高可倍频到64MHz，外部8MHz时钟HSE最高可倍频到72MHz |

版权声明：本文为CSDN博主「fantastic_sky」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/fantastic_sky/article/details/110229474



## 二、环境搭建

​	利用stm32cubemx平台，实现STM32F103C8T6的freertos的多任务机制来完成WS2812B的控制。

​	

​	